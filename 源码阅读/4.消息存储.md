# 4.消息存储

目前的MQ 中间件从存储模型来看，分为需要持久化和不需要持久化的两种模型，现在大多数的M Q 都是支持持久化存储的，比如Act i veMQ 、RabbitMQ 、Kafka,RocketMQ ,而ZeroMQ 却不需要支持持久化存储。然而业务系统也大多需要MQ 有持久存储的能力，能大大增加系统的高可用性。从存储方式和效率来看，文件系统高于KV 存储， KV 存储又高于关系型数据库，直接操作文件系统肯定是最快的，但可靠性却是最低的，而关系型数据库的性能和可靠性与文件系统恰恰相反，第4 章主要分析RocketMQ 的消息存储机制。

## 4.1.存储概要设计

RocketMQ 主要存储的文件包括Comitlog 文件、ConsumeQueue 文件、IndexFile 文件。RocketMQ 将所有主题的消息存储在同－个文件中，确保消息发送时顺序写文件，尽最大的能力确保消息发送的高性能与高吞吐量。但由于消息中间件一般是基于消息主题的订阅机制，这样便给按照消息主题检索消息带来了极大的不便。为了提高消息消费的效率， RocketMQ 引入了ConsumeQueue 消息队列文件，每个消息主题包含多个消息消费队列，每一个消息队列有一个消息文件。Ind 巳xFile 索引文件，其主要设计理念就是为了加速消息的检索性能，根据消息的属性快速从Commitlog 文件中检索消息。RocketMQ 是一款高性能的消息中间件，存储部分的设计是核心，存储的核心是IO 访问性能，本章也会重点剖析RocketMQ 是如何提高IO 访问性能的。进入RocketMQ 存储剖析之前，先看一下RocketMQ 数据流向，如图4-1 所示。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-18-155547.png)

* CommitLog ：消息存储文件，所有消息主题的消息都存储在CommitLog 文件中。
* ConsumeQueue ：消息消费队列，消息到达CommitLog 文件后，将异步转发到消息消费队列，供消息消费者消费。
* IndexFile ：消息索引文件，主要存储消息Key 与Offset 的对应关系。
* 事务状态服务： 存储每条消息的事务状态。
* 定时消息服务：每一个延迟级别对应一个消息消费队列，存储延迟队列的消息拉取进度。

## 4.2.初识消息存储

消息存储实现类： org.apache.rocketmq .store.D efaultMessageStore ，它是存储模块里面最重要的一个类，包含了很多对存储文件操作的API ， 其他模块对消息实体的操作都是通过DefaultMessageStore 进行操作，其类图如图4-2 所示。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-18-160122.png)

让我们来一一介绍DefaultMessageStore 的核心属性。

1. MessageStoreConfig messageStoreConfig ：消息存储配置属性。
2. CommitLog commitLog: CommitLog 文件的存储实现类。
3. ConcurrentMap<String/* topic 灯， ConcurrentMap <Integer/* queueld 叫， C onsume Queue>>consumeQueueTable ：消息队列存储缓存表，按消息主题分组。
4. FlushConsumeQueueService flushConsumeQueueService ：消息队列文件ConsumeQueue刷盘线程。
5. CleanCommitLogService cleanCommitLogService ：清除CommitLog 文件服务。
6. CleanConsumeQueueS 巳rvice cleanConsumeQueueService ： 清除ConsumeQueue 文件服务。
7. IndexService indexService ： 索引文件实现类。
8. AllocateMappedFileService allocateMappedFileService: MappedFile 分配服务。
9. ReputMessageService reputMessageService : CommitLog 消息分发，根据CommitLog文件构建ConsumeQueue 、IndexFile 文件。
10. HAService haService ：存储HA 机制。
11. TransientStorePool transientStorePool ：消息堆内存缓存。
12. MessageArrivingListener messageArrivingListener ：消息拉取长轮询模式消息达到监听器。
13. BrokerConfig brokerConfig: Broker 配置属性。
14. StoreCheckpoint storeCheckpoint ：文件刷盘检测点。
15. LinkedList<CommitLogDispatcher> dispatcher List: CommitLog 文件转发请求。

## 4.3.消息发送存储流程

本节将以消息发送存储为突破点，一点一点揭开RocketMQ 存储设计的神秘面纱。消息存储入口： org.apache.rocketmq.store.DefaultMessageStore#putMessage 。

Step1：如果当前Broker 停止工作或Broker 为SLAVE 角色或当前Rocket 不支持写入则拒绝消息写入；如果消息主题长度超过256 个字符、消息属性长度超过65536 个字符将拒绝该消息写人。

>如果日志中包含“ message store is not writeable, so putMessage is forbidden ” ，出现这种日志最有可能是磁盘空间不足，在写ConsumeQueue 、IndexFile 文件出现错误时会拒绝消息再次写入。

Step2 ：如果消息的延迟级别大于0 ，将消息的原主题名称与原消息队列ID 存入消息属性中，用延迟消息主题SCHEDULE_TOPIC 、消息队列ID 更新原先消息的主题与队列， 这是并发消息消费重试关键的一步，下一章会重点探讨消息重试机制与定时消息的实现原理。

```java
  MappedFile unlockMappedFile = null;
  MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();
```

Step3 ：获取当前可以写入的Commitlog 文件， RocketMQ 物理文件的组织方式如图4-3所示。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-18-162003.png)

Commitlog 文件存储目录为｛ ROCKET_HOME }/store/commitlog 目录，每一个文件默认1G ， 一个文件写满后再创建另外一个，以该文件中第一个偏移量为文件名，偏移量小于20 位用0 补齐。图4 -3 所示的第一个文件初始偏移量为0 ，第二个文件的1073741824 ，代表该文件中的第一条消息的物理偏移量为1073741824 ，这样根据物理偏移量能快速定位到消息。MappedFileQueue 可以看作是｛ ROCKET_HOME }/store/commitlog 文件夹，而MappedFile 则对应该文件夹下一个个的文件。

Step4 ：在写入CornrnitLog 之前，先申请putMessageLock，也就是将消息存储到CornrnitLog 文件中是串行的。

```java
 putMessageLock.lock(); //spin or ReentrantLock ,depending on store config
try {
    long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();
    this.beginTimeInLock = beginLockTimestamp;

    // Here settings are stored timestamp, in order to ensure an orderly
    // global
    msg.setStoreTimestamp(beginLockTimestamp);

    if (null == mappedFile || mappedFile.isFull()) {
        mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise
    }
    if (null == mappedFile) {
        log.error("create mapped file1 error, topic: " + msg.getTopic() + " clientAddr: " + msg.getBornHostString());
        beginTimeInLock = 0;
        return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null);
    }

    result = mappedFile.appendMessage(msg, this.appendMessageCallback);
    switch (result.getStatus()) {
        case PUT_OK:
            break;
        case END_OF_FILE:
            unlockMappedFile = mappedFile;
            // Create a new file, re-write the message
            mappedFile = this.mappedFileQueue.getLastMappedFile(0);
            if (null == mappedFile) {
                // XXX: warn and notify me
                log.error("create mapped file2 error, topic: " + msg.getTopic() + " clientAddr: " + msg.getBornHostString());
                beginTimeInLock = 0;
                return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);
            }
            result = mappedFile.appendMessage(msg, this.appendMessageCallback);
            break;
        case MESSAGE_SIZE_EXCEEDED:
        case PROPERTIES_SIZE_EXCEEDED:
            beginTimeInLock = 0;
            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);
        case UNKNOWN_ERROR:
            beginTimeInLock = 0;
            return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);
        default:
            beginTimeInLock = 0;
            return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);
    }

    eclipseTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;
    beginTimeInLock = 0;
} finally {
    putMessageLock.unlock();
}
```

Step5：设置消息的存储时间，如果mappedFile 为空，表明$ {ROCKET_HOME}/store/commitlog 目录下不存在任何文件，说明本次消息是第一次消息发送，用偏移量0 创建第一个commit 文件，文件为00000000000000000000 ，如果文件创建失败，抛出CREATE_MAPEDFILE_FAILED ，很有可能是磁盘空间不足或权限不够。

```java
    public AppendMessageResult appendMessagesInner(final MessageExt messageExt, final AppendMessageCallback cb) {
        assert messageExt != null;
        assert cb != null;

        int currentPos = this.wrotePosition.get();

        if (currentPos < this.fileSize) {
            ByteBuffer byteBuffer = writeBuffer != null ? writeBuffer.slice() : this.mappedByteBuffer.slice();
            byteBuffer.position(currentPos);
            AppendMessageResult result = null;
            if (messageExt instanceof MessageExtBrokerInner) {
                result = cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBrokerInner) messageExt);
            } else if (messageExt instanceof MessageExtBatch) {
                result = cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBatch) messageExt);
            } else {
                return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);
            }
            this.wrotePosition.addAndGet(result.getWroteBytes());
            this.storeTimestamp = result.getStoreTimestamp();
            return result;
        }
        log.error("MappedFile.appendMessage return null, wrotePosition: {} fileSize: {}", currentPos, this.fileSize);
        return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);
    }
```

Step6：将消息追加到MappedFile 中。首先先获取MappedFile 当前写指针，如果currentPos 大于或等于文件大小则表明文件已写满，抛出AppendMessageStatus.UNKNOWN_ERROR。如果currentPos 小于文件大小，通过slice（）方法创建一个与MappedFile 的共享内存区，并设置position 为当前指针。

```java
// PHY OFFSET
long wroteOffset = fileFromOffset + byteBuffer.position();

this.resetByteBuffer(hostHolder, 8);
String msgId = MessageDecoder.createMessageId(this.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);

```

Step7 ：创建全局唯一消息ID ，消息ID 有16 字节，消息ID 组成如图4-4 所示。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-18-163639.png)

但为了消息ID可读性，返回给应用程序的msgId 为字符类型，可以通过UtilAll.bytes2string 方法将msgId 字节数组转换成字符串，通过Uti1All.string2bytes 方法将msgId字符串还原成16 个字节的字节数组，从而根据提取消息偏移量，可以快速通过msgId 找到消息内容。

```java
// Record ConsumeQueue information
keyBuilder.setLength(0);
keyBuilder.append(msgInner.getTopic());
keyBuilder.append('-');
keyBuilder.append(msgInner.getQueueId());
String key = keyBuilder.toString();
Long queueOffset = CommitLog.this.topicQueueTable.get(key);
if (null == queueOffset) {
    queueOffset = 0L;
    CommitLog.this.topicQueueTable.put(key, queueOffset);
}
```

Step8 ： 获取该消息在消息队列的偏移量。CommitLog 中保存了当前所有消息队列的当前待写入偏移量。

```java
    private static int calMsgLength(int bodyLength, int topicLength, int propertiesLength) {
        final int msgLen = 4 //TOTALSIZE
            + 4 //MAGICCODE
            + 4 //BODYCRC
            + 4 //QUEUEID
            + 4 //FLAG
            + 8 //QUEUEOFFSET
            + 8 //PHYSICALOFFSET
            + 4 //SYSFLAG
            + 8 //BORNTIMESTAMP
            + 8 //BORNHOST
            + 8 //STORETIMESTAMP
            + 8 //STOREHOSTADDRESS
            + 4 //RECONSUMETIMES
            + 8 //Prepared Transaction Offset
            + 4 + (bodyLength > 0 ? bodyLength : 0) //BODY
            + 1 + topicLength //TOPIC
            + 2 + (propertiesLength > 0 ? propertiesLength : 0) //propertiesLength
            + 0;
        return msgLen;
    }
```

Step9 ： 根据消息、体的长度、主题的长度、属性的长度结合消息存储格式计算消息的总长度。

RocketMQ 消息存储格式如下。

* TOTALSIZE ： 该消息条目总长度，4 字节。
* MAGICCODE ： 魔数， 4 字节。固定值Oxdaa320a7 。
* BODYCRC ： 消息体crc校验码， 4 字节。
* QUEUEID ： 消息消费队列ID , 4 字节。
* FLAG ： 消息FLAG , RocketMQ 不做处理， 供应用程序使用，默认4 字节。
* QUEUEOFFSET ：消息在消息消费队列的偏移量， 8 字节。
* PHYSICALOFFSET ： 消息在CommitLog 文件中的偏移量， 8 字节。
* SYSFLAG ： 消息系统Flag ，例如是否压缩、是否是事务消息等， 4 字节。
* BORNTIMESTAMP ： 消息生产者调用消息发送API 的时间戳， 8 字节。
* BORNHOST ：消息发送者IP 、端口号， 8 字节。
* STORETIMESTAMP ： 消息存储时间戳， 8 字节。
* STOREHOSTADDRESS: Broker 服务器IP＋端口号， 8 字节。
* RECONSUMETIMES ： 消息重试次数， 4 字节。
* Prepared Transaction Offset ： 事务消息物理偏移量， 8 字节。
* BodyLength ：消息体长度， 4 字节。
* Body ： 消息体内容，长度为bodyLen th 中存储的值。
* TopieLength ： 主题存储长度， 1 字节，表示主题名称不能超过255 个字符。
* Topic ： 主题，长度为TopieL e n g th 中存储的值。
* PropertiesLength ： 消息属性长度， 2 字节， 表示消息属性长度不能超过6 553 6 个字符。
* Properties ： 消息属性，长度为PropertiesLength 中存储的值。

上述表示CommitLog 条目是不定长的，每一个条目的长度存储在前4 个字节中。

```java
// Determines whether there is sufficient free space
if ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {
    this.resetByteBuffer(this.msgStoreItemMemory, maxBlank);
    // 1 TOTALSIZE
    this.msgStoreItemMemory.putInt(maxBlank);
    // 2 MAGICCODE
    this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);
    // 3 The remaining space may be any value
    // Here the length of the specially set maxBlank
    final long beginTimeMills = CommitLog.this.defaultMessageStore.now();
    byteBuffer.put(this.msgStoreItemMemory.array(), 0, maxBlank);
    return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),
        queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);
}
```

Step1O：如果消息长度＋END_FILE_MIN_BLANK_LENGTH 大于CommitLog 文件的空闲空间，则返回AppendMessageStatus.END_OF_FILE, Broker 会重新创建一个新的CommitLog 文件来存储该消息。从这里可以看出，每个CommitLog 文件最少会空闲8个字节，高4 字节存储当前文件剩余空间，低4 字节存储魔数： CommitLog.BLANK_MAGIC_CODE 。

```java
final long beginTimeMills = CommitLog.this.defaultMessageStore.now();
// Write messages to the queue buffer
byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen);

AppendMessageResult result = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,
    msgInner.getStoreTimestamp(), queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);

```

Step11 ：将消息内容存储到ByteBuffer 中，然后创建AppendMessageResult 。这里只是将消息存储在MappedFile 对应的内存映射Buffer 中，并没有刷写到磁盘，追加结果如图4-5 所示。

![image](https://clsaa-markdown-imgbed-1252032169.cos.ap-shanghai.myqcloud.com/very-java/2019-04-18-170204.png)

下面我们来一一介绍下AppendMessageResult 的属性。

* AppendMessageStatus status ：消息追加结果，取值PUT_OK ： 追加成功； END_OF_FILE: 超过文件大小； MESSAGE_SIZE_EXCEEDED ：消息长度超过最大允许长度：PROPERTIES_SIZE_EXCEEDED ：消息、属性超过最大允许长度； UNKNOWN_ERROR ：未知异常。
* long wroteOffset ：消息的物理偏移量。
* String msgld ：消息ID 。
* long storeTimestamp ：消息存储时间戳。
* long logicsOffset ：消息消费队列逻辑偏移量，类似于数组下标。
* long pagecacheRT = 0 ：当前未使用。
* int msgNum = 1 ：消息条数，批量消息发送时消息条数。

```java
switch (tranType) {
    case MessageSysFlag.TRANSACTION_PREPARED_TYPE:
    case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:
        break;
    case MessageSysFlag.TRANSACTION_NOT_TYPE:
    case MessageSysFlag.TRANSACTION_COMMIT_TYPE:
        // The next update ConsumeQueue information
        CommitLog.this.topicQueueTable.put(key, ++queueOffset);
        break;
    default:
        break;
}
```

Step12 ：更新消息队列逻辑偏移量。
Step13 ：处理完消息追加逻辑后将释放putMessageLock 锁。

```java
  handleDiskFlush(result, putMessageResult, msg);
  handleHA(result, putMessageResult, msg);

  return putMessageResult;
```

Step 14 : DefaultAppendMessageCallback#doAppend 只是将消息追加在内存中， 需要根据是同步刷盘还是异步刷盘方式，将内存中的数据持久化到磁盘，关于刷盘操作后面会详细介绍。然后执行HA 主从同步复制，主从同步将在第7 章详细介绍。消息发送的基本流程就介绍到这里，下一节开始详细剖析RocketMQ 消息存储机制的各个方面。